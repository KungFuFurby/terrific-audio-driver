// Audio Driver
//
// SPDX-FileCopyrightText: © 2023 Marcus Rowe <undisbeliever@gmail.com>
// SPDX-License-Identifier: Zlib
//
// Copyright © 2023 Marcus Rowe <undisbeliever@gmail.com>
//
// This software is provided 'as-is', without any express or implied warranty.  In
// no event will the authors be held liable for any damages arising from the use of
// this software.
//
// Permission is granted to anyone to use this software for any purpose, including
// commercial applications, and to alter it and redistribute it freely, subject to
// the following restrictions:
//
//      1. The origin of this software must not be misrepresented; you must not
//         claim that you wrote the original software. If you use this software in
//         a product, an acknowledgment in the product documentation would be
//         appreciated but is not required.
//
//      2. Altered source versions must be plainly marked as such, and must not be
//         misrepresented as being the original software.
//
//      3. This notice may not be removed or altered from any source distribution.


import "registers";
import "data-formats";
import "io-commands";
import "common_memmap";

config {
    trim = true
}

bank code           @ CODE_ADDR : [constdata;   CODE_SIZE];


extern const commonDataHeader @ COMMON_DATA_ADDR : CommonDataHeader;
let COMMON_DATA_HEADER_END_ADDR = COMMON_DATA_ADDR + sizeof(CommonDataHeader);


// Must wait a minimum of 240ms after setting `EDL` and `ESA` before reading/writing the echo buffer.
//
// Added a little extra to be safe.
let EDL_SLEEP_MS = 250;

// Instead of setting TIMER_0 register to 8 and counting `EDL_SLEEP_MS` clocks, we can set TIMER_0 to `EDL_SLEEP_MS` and wait 8 clocks.
let EDL_SLEEP_TIMER_0 = EDL_SLEEP_MS;
let EDL_SLEEP_COUNT   = smp.TIMER_0_HZ / 1000;

// Assert EDL_SLEEP_COUNT < 12



// Variables
// =========

let FIRST_MUSIC_CHANNEL = 0;
let LAST_MUSIC_CHANNEL = N_MUSIC_CHANNELS - 1;
let FIRST_SFX_CHANNEL = LAST_MUSIC_CHANNEL + 1;
let LAST_SFX_CHANNEL = N_CHANNELS - 1;


in zeropage {
    // Temporary variables
    var zpTmp : u8;
    var zpTmp2 : u8;


    // Common audio data addresses
    // See `data-formats.wiz` for more details about these variables.
    namespace commonData {
        var instruments_scrn : *u8;
        var instruments_pitchOffset : *u8;
        var instruments_adsr1 : *u8;
        var instruments_adsr2OrGain : *u8;

        var soundEffects_addr_l : *u8;
        var soundEffects_addr_h : *u8;
        var soundEffects_durationAndInterruptFlag_l : *u8;
        var soundEffects_durationAndInterruptFlag_h : *u8;
    }

    // Increases once every song tick
    var songTickCounter : u16;


    // Enabled or disabled music channels.
    // A bitmask of the music channels that can send key-on events.
    //
    // This bitmask is set by the SET_MUSIC_CHANNELS IO comamnd, it is not `keyOnMask`.
    var io_musicChannelsMask : u8;


    // The previous IO port command
    var previousCommand : u8;


    // The table of subroutine offsets
    var subroutineTable_l : *const u8;
    var subroutineTable_h : *const u8;

    // Maximum value of the timer counter_0 or counter_1 register.
    var maxTimerCounter : u8;


    // bitmask - Set if S-DSP voice channel is music, clear if sfx.
    // Used to disable music channel S-DSP writes that are used by sound effects.
    // Bits 0-5 MUST be set.
    // MUST ONLY be modified by `_process_sfx_channels__inline()`.
    var musicSfxChannelMask : u8;

    // bitmask - Set if S-DSP voice channel is sfx.
    // Used to disable S-DSP voice register writes for unused sfx channels.
    // Used to determine the next available sound effect channel.
    var activeSoundEffects : u8;

    // bitmask - Set if the sound effect is interruptible
    // (only uses bits 6 & 7)
    var sfx_interruptibleFlags : u8;


    // The remaining duration of the two sound effects in ticks
    var sfx_remainingTicks : [u16 ; N_SFX_CHANNELS];


    // S-DSP voice channels dirty flags.
    // Used to test if the virtualChannels should be written to the S-DSP voice registers.
    // (using a bitset so they can be masked when channel ducking)
    var voiceChannelsDirty_music : u8;
    var voiceChannelsDirty_sfx   : u8;


    // Shadow variables for KOFF DSP register
    var keyOffShadow_music : u8;
    var keyOffShadow_sfx : u8;

    // Shadow variables for KON DSP register
    var keyOnShadow_music : u8;
    var keyOnShadow_sfx : u8;

    // Shadow variable for the EON S-DSP register
    var eonShadow_music : u8;
    var eonShadow_sfx : u8;


    // `keyOnShadow` mask.
    //
    // Each bit determines the channel bytecode should emit a key-on event.
    //  * If set - the next play note instruction will set `keyOnShadow`.
    //  * If clear - the channel is playing something and the play note instruction will
    //               leave `keyOnShadow` unchanged (slurring the note).
    // (8x bitfield)
    var keyOnMask_music : u8;
    var keyOnMask_sfx : u8;


    // Only valid inside bytecode instructions
    var instructionPtr : *const u8;


    // Temporary variable for reading and writing `voiceChannelsDirty_*` bits.
    //
    // MUST ONLY be written to in `__process_channels()`.
    var voiceChannelsDirty_tmp  : u8;

    // The one-past-the-end index when looping through the channels.
    //
    // Used to deduplicate code when processing music and sound effects.
    //
    // MUST ONLY BE USED IN `__process_channels()`.
    var channelIndexEndLoop : u8;


    namespace channelSoA {
        // Counter (in ticks) until the event
        var countdownTimer : [u8 ; N_CHANNELS];

        // If non-zero, the next event is a key-off event
        // If zero, the next event will process bytecode
        var nextEventIsKeyOff : [u8 ; N_CHANNELS];


        // S-DSP voice register shadows (AKA Virtual Channels)
        namespace virtualChannels {
            var vol_l       : [u8 ; N_CHANNELS];
            var vol_r       : [u8 ; N_CHANNELS];
            var pitch_l     : [u8 ; N_CHANNELS];
            var pitch_h     : [u8 ; N_CHANNELS];
            var scrn        : [u8 ; N_CHANNELS];
            var adsr1       : [u8 ; N_CHANNELS];
            // If the MSB of adsr1 is set, this value is written to the ADSR2 register.
            // If the MSB of adsr1 is clear, this value is written to the GAIN register.
            var adsr2OrGain : [u8 ; N_CHANNELS];
        }


        // The address of the next bytecode to execute.
        //
        // If the high-byte of the instructionPtr is 0, no bytecode will be executed.
        //
        // (The low-byte of instructionPtr is in firstpage)
        var instructionPtr_h : [u8 ; N_CHANNELS];


        // Number of remaining loops
        var loopState_counter : [[u8 ; N_CHANNELS] ; bytecode.MAX_NESTED_LOOPS];


        // Used to determine if vol_l and vol_r need recalculating.
        //
        // This is a per-channel flag so it can be cleared in __reset_channel().
        //
        // As the spc700 lacks a `stz dp+X` instruction, I am using `LSR dp+X` to clear this value.
        // Only the MSB is tested when reading this flag.
        var volShadowValid : [u8 ; N_CHANNELS];

        // Channel volume (0-255)
        var volume : [u8 ; N_CHANNELS];


        // Portamento direction
        //  * zero - portamento disabled
        //  *  > 0 - increase pitch
        //  *  < 0 - decrease pitch
        var portamento_direction : [i8 ; N_CHANNELS];



        // Vibrato PITCH offset per tick.
        //
        // If this value is 0, vibrato is disabled.
        //
        // (pitch change/tick)
        var vibrato_pitchOffsetPerTick : [u8 ; N_CHANNELS];

        // Vibrato tick counter
        //  * Starts at `vibrato_tickCounterStart` to offset the vibrato pitch-shift
        //  * Counts down from `vibrato_waveLengthInTicks` to 0.
        //  * If 0, there are 256 ticks remaining
        var vibrato_tickCounter : [u8 ; N_CHANNELS];
    }
}


in firstpage {

    // Channel variables that do not fit in zeropage
    namespace channelSoA {
        // Portamento PITCH speed
        // (pitch change/tick)
        var portamento_speed : [u8 ; N_CHANNELS];

        // Portamento target pitch
        var portamento_target_l : [u8 ; N_CHANNELS];
        var portamento_target_h : [u8 ; N_CHANNELS];


        // Used to determine the vibrato pitch shift direction for the current vibrato tick counter.
        //
        // This variable is equal to `vibrato_waveLengthInTicks / 2`
        var vibrato_directionComparator : [u8 ; N_CHANNELS];

        // The length of the vibrato wavelength in ticks.
        //
        // If this value is 0. The wavelength is 256 ticks.
        //
        // This variable is equal to `4 * vibrato_tickCounterStart`
        var vibrato_waveLengthInTicks : [u8 ; N_CHANNELS];

        // The value to reset the tick counter to when playing a note or starting a vibrato.
        //
        // This variable is equal to the `quarterWavelengthInTicks` parameter of the `set_vibrato` instruction
        // This variable is equal to `vibrato_waveLengthInTicks / 4`
        //
        // Offsetting the start of the vibrato allows me to save a comparison in `process_pitch_effects__inline()`.
        var vibrato_tickCounterStart : [u8 ; N_CHANNELS];


        // The address of the next bytecode to execute
        // (The high-byte of instructionPtr is in firstpage)
        var instructionPtr_l : [u8 ; N_CHANNELS];

        // Address to return to in a `return_from_subroutine` bytecode
        //
        // If `returnInstPtr_h` is 0, `return_from_subroutine` will disable the channel instead.
        var returnInstPtr_l : [u8 ; N_CHANNELS];
        var returnInstPtr_h : [u8 ; N_CHANNELS];


        // Instruction pointer at the start of the loop.
        var loopState_loopPoint_l : [[u8 ; N_CHANNELS] ; bytecode.MAX_NESTED_LOOPS];
        var loopState_loopPoint_h : [[u8 ; N_CHANNELS] ; bytecode.MAX_NESTED_LOOPS];


        // Bytecode address to loop to when the channel encounters and `end` instruction.
        // If `instructionPtrAfterEnd_h` is 0, the channel does not loop and will instead stop.
        var instructionPtrAfterEnd_l : [u8 ; N_CHANNELS];
        var instructionPtrAfterEnd_h : [u8 ; N_CHANNELS];


        // Channel pan (0-MAX_PAN)
        var pan : [u8 ; N_CHANNELS];


        // Offset between the note to play and the pitch table.
        //
        // NOTE: Adding `instPitchOffset` to the note to play is allowed to an can overflow.
        var instPitchOffset : [u8 ; N_CHANNELS];
    }
}


// Macros
// ======

// KEEP: a, x, y
inline func write_dsp(addr : GlobalDspAddr in a, data : u8 in y) {
    smp.dsp_addr_and_data = ya;
}


// ::BUGFIG This inline func fixes a "left-hand side of type `u16` cannot be assigned `u8` expression" error when multiplying a and y::
inline func mul(u8a : u8 in a, u8b : u8 in y) : u16 in ya {
    return a * y;
}



// Code
// ====

in code {

// MUST be the first thing in the `code` bank (so the starting address is consistent across builds).
func main() {
    sp = x = 0xff;
    direct_page = false;

    // Tell the S-CPU the S-SMP is running the audio driver
    IO.ToScpu.mode = IO.ToScpu.MODE_AUDIO_DRIVER;

    // Reset the DSP
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__SOFT_RESET | dsp.FLG__MUTE_ALL | dsp.FLG__ECHO_DISABLE);

    write_dsp(GlobalDspAddr.KOFF,   0xff);  // all keys off


    // Setup echo.
    //
    // This is done as soon as possible as we need to wait a while after setting EDL and ESA.
    {
        // Assumes ECHO write is disabled.

        y = offsetof(SongHeader, echo);

        // EchoBufferSettings.edl (mask for safety)
        a = songPtr[y] & 0xf;
        y++;

        // Set EDL
        smp.dsp_addr = GlobalDspAddr.EDL as u8;
        smp.dsp_data = a;


        // Calculate echo address

        // a = 0x100 - a * (2048 / 256)

        // Multiply by 8
        // (XCN is safe, A has been masked)
        swap_digits(a);
        a >>>= 1;

        // Negate A
        a ^= 0xff;
        a++;

        if zero {
            // Ensure echo buffer is at the end of audio-ram when EDL is 0
            // When EDL is 0, the echo buffer is 4 bytes in size.
            a--;
        }

        // set ESA (Echo start address??)
        // Assumes GlobalDspAddr.ESA | 0x10 = GlobalDspAddr.EDL
        smp.dsp_addr $ 4 = false;
        smp.dsp_data = a;

        // Save S-DSP ESA for later.
        push(a);


        // `EDL` does not take affect immediately.
        // The S-DSP reads `EDL` when the echo buffer is full and wraps around.
        //
        // Since `EDL` starts in an uninitialised state, we must wait a minimum of 240ms before
        // setting echo volume or enabling echo writes.
        //
        // Setup a timer here and enable echo writes at the end of driver initialization.
        //
        // Source: fullsnes https://problemkaputt.de/fullsnes.htm#snesapudspechoregisters

        smp.timer_0 = EDL_SLEEP_TIMER_0;

        // Reset and enable timer 0 (timers are reset on a transition from 0 to 1)
        smp.control = 0;
        smp.control = smp.CONTROL__ENABLE_TIMER_0;


        // Copy FIR filter from header to C0-C7
        smp.dsp_addr = GlobalDspAddr.C0 as u8;
        do {
            // EchoBufferSettings.firFilter
            smp.dsp_data = a = songPtr[y];
            y++;

            // Assumes GlobalDspAddr.C1 - GlobalDspAddr.C0 == 0x10
            // Assumes GlobalDspAddr.C7 + 0x10 >= 0x80
            smp.dsp_addr += 0x10;
        } while !negative;


        // EchoBufferSettings.echoFeedback
        a = songPtr[y];
        y++;

        smp.dsp_addr = GlobalDspAddr.EFB as u8;
        smp.dsp_data = a;


        // EchoBufferSettings.echoVolume
        a = songPtr[y];

        smp.dsp_addr = GlobalDspAddr.EVOL_L as u8;
        smp.dsp_data = a;

        // Assumes GlobalDspAddr.EVOL_R = GlobalDspAddr.EVOL_L | 0x10
        smp.dsp_addr $ 4 = true;
        smp.dsp_data = a;
    }

    // A copy of S-DSP `ESA` is on the stack.


    y = 0;
    write_dsp(GlobalDspAddr.PMON,   y);     // No pitch modulation
    write_dsp(GlobalDspAddr.NON,    y);     // No noise
    write_dsp(GlobalDspAddr.EON,    y);     // No echo


    // Set main volume to full volume
    y = 0x7f;
    write_dsp(GlobalDspAddr.MVOL_L, y);
    write_dsp(GlobalDspAddr.MVOL_R, y);

    // Set directory table
    write_dsp(GlobalDspAddr.DIR, >:COMMON_DATA_HEADER_END_ADDR);


    // Clear all zero-page variables before `songPtr`.
    // Assumes `songPtr` and `loaderDataType` is AFTER `zeropage` bank.
    a = 0;
    x = &songPtr as u8;
    do {
        x--;
        *(x as *u8) = a;
    } while !zero;


    a = 0xff;
    io_musicChannelsMask = a;
    musicSfxChannelMask = a;
    keyOnMask_music = a;


    // Calculate common audio data addresses
    {
        // Reuse these two variables for temporary word space
        var _nInstruments  : u16 in instructionPtr;
        var _nSoundEffects : u16 in subroutineTable_l;

        a = commonDataHeader.nInstruments;
        y = 0;
        _nInstruments = ya;

        a = commonDataHeader.nSoundEffects;
        // y = 0
        _nSoundEffects = ya;


        // Calculate `instruments` address (COMMON_DATA_HEADER_END_ADDR + nDirItems * 4)
        a = <:COMMON_DATA_HEADER_END_ADDR;
        y = >:COMMON_DATA_HEADER_END_ADDR;
        commonData.instruments_scrn = ya as *u8;

        ya = mul(commonDataHeader.nDirItems, sizeof(DirItem));
        ya += commonData.instruments_scrn as u16;

        *(&commonData.instruments_scrn as *u16)        = ya;
        *(&commonData.instruments_pitchOffset as *u16) = ya = ya + _nInstruments;
        *(&commonData.instruments_adsr1 as *u16)       = ya = ya + _nInstruments;
        *(&commonData.instruments_adsr2OrGain as *u16) = ya = ya + _nInstruments;

        *(&commonData.soundEffects_addr_l as *u16)                      = ya = ya + _nInstruments;
        *(&commonData.soundEffects_addr_h as *u16)                      = ya = ya + _nSoundEffects;
        *(&commonData.soundEffects_durationAndInterruptFlag_l as *u16)  = ya = ya + _nSoundEffects;
        *(&commonData.soundEffects_durationAndInterruptFlag_h as *u16)  = ya = ya + _nSoundEffects;
    }


    // Calculate `subroutineTable` addresses.
    // subroutineTable_l = songPtr + sizeof(SongHeader)
    a = sizeof(SongHeader);
    y = 0;
    ya += songPtr as u16;
    subroutineTable_l = ya as *const u8;

    // subroutineTable_h = subroutineTable_l + nSubroutines
    y = offsetof(SongHeader, nSubroutines);
    a = songPtr[y];
    y = 0;
    ya += subroutineTable_l as u16;
    subroutineTable_h = ya as *const u8;


    // Reset all music channels
    zpTmp = MAX_PAN / 2;

    x = N_MUSIC_CHANNELS - 1;
    do {
        __reset_channel(x, zpTmp);

        // ASSUMES offsetof(SongHeader, channels) == 0
        // ASSUMES sizeof(MusicChannelHeader) == 4
        y = a = x <<< 2;

        // Calculate instructionPtr (disabling the channel if the addition overflows)
        channelSoA.instructionPtr_l[x] = a = songPtr[y] + <:songPtr;
        y++;
        a = songPtr[y] +# >:songPtr;
        if carry {
            // Disable channel
            a = 0;
        }
        channelSoA.instructionPtr_h[x] = a;
        y++;

        // Calculate endInstPtr (and set the high byte to 0 (no looping) if the addition overflows)
        channelSoA.instructionPtrAfterEnd_l[x] = a = songPtr[y] + <:songPtr;
        y++;
        a = songPtr[y] +# >:songPtr;
        if carry {
            a = 0;
        }
        channelSoA.instructionPtrAfterEnd_h[x] = a;

        x--;
    } while !negative;


    // No need to reset SFX channels.
    // The sfx channels are disabled as `instructionPtr_h` is 0.


    // Pop ESA from the stack
    x = pop();


    // Skip echo buffer clear and `EDL` sleep if the SKIP_ECHO_BUFFER_RESET_BIT bit is set
    //
    // WARNING: Skipping the `EDL` sleep can corrupt memory when echo writes are enabled.
    //
    // (cannot use `bbs` instructions in wiz, using `mov1 c, addr, bit` instead)
    carry = loaderDataType $ LoaderDataType.SKIP_ECHO_BUFFER_RESET_BIT;
    if !carry {
        // Clear the echo buffer
        // X = S-DSP ESA
        __clear_echo_buffer__inline(x);


        // Wait until the echo buffer can be safely written to.
        // (wait until `EDL_SLEEP_COUNT` ticks of TIMER_0)
        a = EDL_SLEEP_COUNT - 1;
        do {
            a -= smp.counter_0;
        } while carry;
    }

    // Enable echo write and unmute the DSP
    write_dsp(GlobalDspAddr.FLG, 0);


    // Setup and enable the timers
    y = offsetof(SongHeader, tickTimer);
    smp.timer_0 = a = songPtr[y];

    smp.timer_1 = SFX_TICK_CLOCK;

    // Timers are enabled and reset in `io_commands.unpause()`


    io_commands.init__inline();


    // Reset counters to ensure `maxTimerCounter` is accurate
    // Timers and counters reset when the timer control bits transition from 0 to 1
    smp.control = 0;

    // (cannot use `bbs` instructions in wiz, using `mov1 c, addr, bit` instead)
    carry = loaderDataType $ LoaderDataType.PLAY_SONG_BIT;
    if carry {
        smp.control = smp.CONTROL__ENABLE_TIMER_0 | smp.CONTROL__ENABLE_TIMER_1;
    }

    ^while true {
        io_commands.process_io_ports__inline();

        // Song tick timer
        a = smp.counter_0;
        if !zero {
            if a >= maxTimerCounter {
                maxTimerCounter = a;
            }

            songTickCounter++;

            _process_music_channels__inline();
        }

        // SFX tick timer
        a = smp.counter_1;
        if !zero {
            if a >= maxTimerCounter {
                maxTimerCounter = a;
            }

            _process_sfx_channels__inline();
        }
    }
}



// Clears the echo buffer.
//
// ASSUMES: IPL is disabled
// ASSUMES: X matches the `ESA` S-DSP register
//
// WARNING: Can clobber the entirely of Audio-RAM if `esa` is invalid.
//
// WARNING: self modifying code
inline func __clear_echo_buffer__inline(esa : u8 in x) {
    // X = page address of the start of the echo buffer
    // Echo buffer ends at the end of memory.

    // Set the high byte of the `mov !abs+Y, a` instructions.
    (&STA_1 as *u8)[2] = x;
    (&STA_2 as *u8)[2] = x;

    a = 0;

    // Have to use a manual loop so the above code can access the `MOV_absY_A` label.
    OuterLoop:
        y = 0x80;
        InnerLoop:
            // Write 2 bytes every loop.
            // Writing 1 byte per loop is too slow (COUNTER_0 is 11 when it should be <=8 (TIMER_0=250)).
        STA_1:
            (0x0000 as *u8)[y] = a;
        STA_2:
            (0x0080 as *u8)[y] = a;

            goto InnerLoop if --y != 0;

        // Advance to the next page
        (&STA_1 as *u8)[2]++;
        (&STA_2 as *u8)[2]++;
        goto OuterLoop if !zero;
}


inline func _process_music_channels__inline() {
    y = a = keyOffShadow_music & musicSfxChannelMask;
    write_dsp(GlobalDspAddr.KOFF, y);

    zpTmp = a = keyOnShadow_music & musicSfxChannelMask & io_musicChannelsMask;

    keyOnShadow_music = 0;
    keyOffShadow_music = 0;

    a = voiceChannelsDirty_music & musicSfxChannelMask;
    __process_channels(a, zpTmp, FIRST_MUSIC_CHANNEL + 1, LAST_MUSIC_CHANNEL + 1);

    voiceChannelsDirty_music = voiceChannelsDirty_tmp;
}


inline func _process_sfx_channels__inline() {
    // No need to mask sfx keyOff/keyOn events.
    // The sfx channels do not emit key-off or key-on events when disabled.

    // Update `musicSfxChannelMask`.
    // Music channels can only write to the S-DSP when the sound effect is disabled AND there is no key-off event.
    // Prevents an audio glitch when a music channel writes to a voice channel in the middle of the key-off release envelope.
    musicSfxChannelMask = a = (activeSoundEffects | keyOffShadow_sfx) ^ 0xff;

    write_dsp(GlobalDspAddr.KOFF, keyOffShadow_sfx);

    zpTmp = keyOnShadow_sfx;

    keyOnShadow_sfx = 0;
    keyOffShadow_sfx = 0;

    // DSP voice register writes must be masked
    a = voiceChannelsDirty_sfx & activeSoundEffects;
    __process_channels(a, zpTmp, FIRST_SFX_CHANNEL + 1, LAST_SFX_CHANNEL + 1);

    voiceChannelsDirty_sfx = voiceChannelsDirty_tmp;

    inline for let _I in 0..(N_SFX_CHANNELS - 1) {
        sfx_remainingTicks[_I]--;
    }
}


// Update the DSP voice registers, write to EON & KON, then execute channel bytecode.
//
// CAUTION: This function DOES NOT write to the `KOFF` S-DSP register.
func __process_channels(validChannels : u8 in a, konShadow: u8 in zpTmp, afterFirstChannel: u8 in zpTmp2, afterLastChannel: u8 in x) {
var _konShadow : u8 in zpTmp;
var _afterFirstChannel : u8 in zpTmp2;

    channelIndexEndLoop = x;

    // This loop MUST read the channels (and voiceChannelsDirty_tmp) in the opposite order
    // to the loop below this one.
    // That way I can populate `_voiceChannelsDirty_tmp` using `ROR` and read it with `ASL`.
    voiceChannelsDirty_tmp = a;
    do {
        x--;

        voiceChannelsDirty_tmp <<<= 1;
        if carry {
            a = LastVoiceRegister[x];

            // Voice registers are written in reverse order so the ADSR2/GAIN voice register is
            // written BEFORE the ADSR1 voice register.
            //
            // This prevents a race-condition that can occur when changing the envelope from ADSR to
            // GAIN (or vice versa).  If the race-condition occurs, the previous ADSR2/GAIN value is
            // erroneously used for a single sample.
            //
            // This race condition can affect multiple samples if the previous GAIN was a fixed
            // value and thus audible to the listener.

            // Need to test which register (ADSR2 or GAIN) to write to.
            y = channelSoA.virtualChannels.adsr1[x];
            if negative {
                a--;
            }
            y = channelSoA.virtualChannels.adsr2OrGain[x];
            smp.dsp_addr_and_data = ya;

            // A = GAIN (0x?7) or ADSR2 (0x?6)
            a &= 0b1111_0110;
            // A = 0x?6
            a--;
            // A = ADSR1 (0x?5)
            y = channelSoA.virtualChannels.adsr1[x];
            smp.dsp_addr_and_data = ya;

            a--;
            y = channelSoA.virtualChannels.scrn[x];
            smp.dsp_addr_and_data = ya;

            a--;
            y = channelSoA.virtualChannels.pitch_h[x];
            smp.dsp_addr_and_data = ya;

            a--;
            y = channelSoA.virtualChannels.pitch_l[x];
            smp.dsp_addr_and_data = ya;

            a--;
            y = channelSoA.virtualChannels.vol_r[x];
            smp.dsp_addr_and_data = ya;

            a--;
            y = channelSoA.virtualChannels.vol_l[x];
            smp.dsp_addr_and_data = ya;
        }
    } while x >= _afterFirstChannel;


    // ASSUMES `eonShadow_sfx` only set for active sfx channels
    y = a = (eonShadow_music & musicSfxChannelMask) | eonShadow_sfx;
    write_dsp(GlobalDspAddr.EON, y);

    write_dsp(GlobalDspAddr.KON, _konShadow);


    ^do {
        // MUST NOT use temporary variables in this loop.

        carry = process_pitch_effects__inline(x);

        voiceChannelsDirty_tmp >>>>#= 1;

        channelSoA.countdownTimer[x]--;
        if zero {
            // Check if a KEY_OFF is required
            a = channelSoA.nextEventIsKeyOff[x];
            if !zero {
                a = ChannelVoiceBit[x];
                if x >= FIRST_SFX_CHANNEL {
                    test_and_set(a, keyOffShadow_sfx);
                    test_and_set(a, keyOnMask_sfx);
                }
                else {
                    test_and_set(a, keyOffShadow_music);
                    test_and_set(a, keyOnMask_music);
                }

                // schedule a bytecode event
                channelSoA.nextEventIsKeyOff[x] = a = 0;

                // Previous countdownTimer value was 0
                channelSoA.countdownTimer[x]++;
            }
            else {
                y = channelSoA.instructionPtr_h[x];
                if !zero {
                    a = channelSoA.instructionPtr_l[x];
                    process_bytecode(x, ya);

                    ya = instructionPtr as u16;
                    channelSoA.instructionPtr_l[x] = a;
                    channelSoA.instructionPtr_h[x] = y;

                    // Request S-DSP voice register update (set dirty bit).
                    // The bytecode most likely changed the virtual channel.
                    //
                    // The flag is set here (and once) instead of every instruction that changes
                    // `channelSoA.virtualChannels` to save a lot of code space.
                    //
                    voiceChannelsDirty_tmp $ 7 = true;

                    _update_vol_shadow_if_required__inline(x);
                }
            }
        }

        x++;
    } while x < channelIndexEndLoop;
}


// IO Ports
// ========

namespace io_commands {

inline func init__inline() {
    // Assumes audio driver starts paused.
    // Assumes IO.Command.PAUSE is 0
    // Assumes `IO.ToDriver.command` is non-zero from the loader.

    a = IO.Command.PAUSE as u8;
    IO.ToScpu.command_ack = a;
    previousCommand = a;
}


inline func process_io_ports__inline() {
    // If the S-CPU writes to an IO port at the same time S-SMP reads from the
    // same IO port, the S-SMP will read invalid data.
    //
    // To detect this bug the IO-Port is read twice and the command is only
    // processed if both reads are the same.
    //
    // Once the command byte has been read successfully, the two parameter bytes
    // do not need to be double-read because:
    //  * The S-CPU will wait until the command has been acknowledged before
    //    writing a new command
    //  * The parameter bytes are written before the command byte is written.

    // Test if `IO.command_id` has changed.
    a = IO.ToDriver.command;
    if a != previousCommand {
        if a == IO.ToDriver.command {
            // MUST set previousCommand before executing command
            // (`pause()` changes previousCommand)
            previousCommand = a;

            y = IO.ToDriver.parameter0;
            __call_command(a, y);

            // Acknowledge command
            IO.ToScpu.command_ack = previousCommand;
        }
    }


    // Execute the loader if the _SWITCH_TO_LOADER_BIT is set.
    //
    // (cannot use `bbc` instructions in wiz, using two `MOV1 ; bcc` instructions instead)
    carry = IO.ToDriver.switch_to_loader $ IO.ToDriver._SWITCH_TO_LOADER_BIT;
    if carry {
        // Read the IO port a second time just in case it was a glitch
        carry = IO.ToDriver.switch_to_loader $ IO.ToDriver._SWITCH_TO_LOADER_BIT;
        if carry {
            ^goto (LOADER_ADDR as func);
        }
    }
}


// NOTE: Does not acknowledge command
func __call_command(command : u8 in a, parameter : u8 in y) {
    x = a = a & IO.ToDriver.COMMAND_MASK;
    goto CommandFunctionTable[unaligned x];
}


// MUST match `Command` enum in `io-commands.wiz`
const CommandFunctionTable : [func(parameter0: u8 in y) ; IO.ToDriver.N_COMMANDS] = [
    pause as func(u8 in y),
    pause_music_play_sfx as func(u8 in y),
    unpause as func(u8 in y),
    play_sound_effect,
    stop_sound_effects,
    set_main_volume,
    set_music_channels,
    set_song_tempo,
];


// Pause music and sound effects
func pause() {
    return __write_control_and_keyoff(
        0,  // Disable timers
        0xff, // key-off all channels
    );
}


#[fallthrough]
func pause_music_play_sfx() {
    a = smp.CONTROL__ENABLE_TIMER_1; // Disable music timer, enable sfx timer
    y = musicSfxChannelMask; // key-off music channels

// fallthrough
}

func __write_control_and_keyoff(control : u8 in a, channelsMask: u8 in y) {
    smp.control = a;
    write_dsp(GlobalDspAddr.KOFF, y);
}


func unpause() {
    // Enable music and sfx timers
    smp.control = smp.CONTROL__ENABLE_TIMER_0 | smp.CONTROL__ENABLE_TIMER_1;
}


func set_main_volume(volume : u8 in y) {
    write_dsp(GlobalDspAddr.MVOL_L, y);
    write_dsp(GlobalDspAddr.MVOL_R, y);
}


func set_music_channels(mask : u8 in y) {
    io_musicChannelsMask = y;
}


func set_song_tempo(tempo : u8 in y) {
    if y < MIN_TICK_CLOCK {
        y = MIN_TICK_CLOCK;
    }
    smp.timer_0 = y;
}


func stop_sound_effects(unused : u8 in y) {
    // ::TODO optimise::

    x = N_MUSIC_CHANNELS;
    do {
        channelSoA.instructionPtr_l[x] = a = <:&ChannelDisabledBytecode;
        channelSoA.instructionPtr_h[x] = y = >:&ChannelDisabledBytecode;

        // Immediately process the next event
        channelSoA.countdownTimer[x] = a = 1;

        x++;
    } while x < N_CHANNELS;
}


func play_sound_effect(sfx_id : u8 in y) {
    let BOTH_SFX_ACTIVE = (1 << 7) | (1 << 6);

    if y < commonDataHeader.nSoundEffects {
        a = activeSoundEffects;
        if a >= BOTH_SFX_ACTIVE {
            // Both sound effect channels are active,

            // Drop sfx_id if it is a low-priority sound effect
            goto Return if y >= commonDataHeader.firstLowPrioritySfx;

            a = sfx_interruptibleFlags;
            if a >= BOTH_SFX_ACTIVE {
                // Both sound effects can be interrupted
                // check remaining ticks and drop the sound effect that will finish first.

                // Assumes 2 sound effect channels
                ya = sfx_remainingTicks[0];
                cmp(ya, sfx_remainingTicks[1]);

                y = IO.ToDriver.parameter0;
                goto _play_sfx_0 if !carry;
                goto _play_sfx_1;
            }

            // Play sound effect if a channel is interruptible
            a <<<= 1;
            goto _play_sfx_1 if carry;
            goto _play_sfx_0 if negative;
        }
        else {
            // At most 1 sound effect channel is active
            a <<<= 1;
            goto _play_sfx_1 if !carry;
            goto _play_sfx_0;
        }
    }
Return:
}


inline func __play_sfx__inline(let _I : u8, sfx_id : u8 in y) {
    let BIT = 8 - N_SFX_CHANNELS + _I;

    <:sfx_remainingTicks[_I] = a = commonData.soundEffects_durationAndInterruptFlag_l[y];
    >:sfx_remainingTicks[_I] = a = commonData.soundEffects_durationAndInterruptFlag_h[y];

    a <<<= 1;
    sfx_interruptibleFlags $ BIT = carry;
}

func _play_sfx_0(sfx_id : u8 in y) {
    __play_sfx__inline(0, y);
    return __play_sfx_on_channel(FIRST_SFX_CHANNEL, y);
}

#[fallthrough]
func _play_sfx_1(sfx_id : u8 in y) {
    __play_sfx__inline(1, y);

    x = LAST_SFX_CHANNEL;
// Fallthrough
}


// ASSUMES: sfx_id < commonData.nSoundEffects
// KEEP: X
#[fallthrough]
func __play_sfx_on_channel(channelIndex : u8 in x, sfx_id : u8 in y) {
    // pan
    zpTmp = IO.ToDriver.parameter1;

    channelSoA.instructionPtr_l[x] = a = commonData.soundEffects_addr_l[y];
    channelSoA.instructionPtr_h[x] = a = commonData.soundEffects_addr_h[y];


    a = ChannelVoiceBit[x];
    // Send a key-off event, the S-DSP voice channel might be active.
    test_and_set(a, keyOffShadow_sfx);
    // Set keyOnMask.  The next play-note instruction will queue a KON event.
    test_and_set(a, keyOnMask_sfx);
    // Disable echo
    test_and_clear(a, eonShadow_sfx);

    // Enable sfx channel.
    test_and_set(a, activeSoundEffects);


// Fallthrough into __reset_channel()
}

}

// NOTE: Does not set:
//  * channelSoA.instructionPtr
//  * instrument/envelope
//  * virtual channels
//  * keyOnMask
//  * eonShadow
//
// NOTE: Also disables `end` looping (instructionPtrAfterEnd).
//
// KEEP: X
func __reset_channel(channelIndex : u8 in x, pan: u8 in zpTmp) {
    a = 0;

    channelSoA.instructionPtrAfterEnd_h[x] = a;     // don't loop SFX
    channelSoA.returnInstPtr_h[x] = a;              // clear subroutine return ptr

    // Disable portamento
    channelSoA.portamento_direction[x] = a as i8;

    // Disable vibrato
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;

    // Clear volShadowValid flag, so vol_l and vol_r is updated after the next bytecode instruction.
    channelSoA.volShadowValid[x] = a;   // a = 0

    // Immediately process bytecode on the next tick
    channelSoA.nextEventIsKeyOff[x] = a; // a = 0
    a++;
    channelSoA.countdownTimer[x] = a;    // a = 1

    // Set channel volume
    channelSoA.volume[x] = a = STARTING_VOLUME;
    channelSoA.pan[x] = a = pan;
}


// Volume and Pan
// ==============


// KEEP: x
inline func clear_vol_shadow_valid_flag(channelIndex : u8 in x) {
    // No `STZ dp+X` instruction, using `LSR dp+X` instead.
    // Safe as I only use the MSB of `volShadowValid` to read the flag value.
    channelSoA.volShadowValid[x] >>>= 1;
}



// Checks the volShadowValid flag and update vol_l and vol_r shadow variables if required.
//
// NOTE: Does not change `channelSoA.virtualChannels.updateState[x]`.
//
// KEEP: x
inline func _update_vol_shadow_if_required__inline(channelIndex : u8 in x) {

    a = channelSoA.volShadowValid[x];
    if !negative {
        // volShadowValid flag clear.
        channelSoA.volShadowValid[x] = a = 0xff;

        // Reading carry here saves a `SEC` instruction when calculating VOL_R
        carry = loaderDataType $ LoaderDataType.STEREO_FLAG_BIT;
        if carry {
            // Stereo

            // Calculate right volume
            // A pan value of `MAX_PAN` is 100% to the right.
            // (MUST NOT USE CARRY)

            a = channelSoA.pan[x];
            y = channelSoA.volume[x];
            ya = mul(a, y);
            channelSoA.virtualChannels.vol_r[x] = y;


            // Calculate left volume
            // A pan value of `0` is 100% to the left.

            // Carry set (MUL does not set carry)
            a = MAX_PAN -# channelSoA.pan[x];
            y = channelSoA.volume[x];
            ya = mul(a, y);
            channelSoA.virtualChannels.vol_l[x] = y;
        }
        else {
            // Mono

            // First shift converts 8-bit volume to 7-bit VOL
            // Second shift ensure mono vol has same combined amplitude as stereo vol
            a = channelSoA.volume[x] >>> 2;

            channelSoA.virtualChannels.vol_l[x] = a;
            channelSoA.virtualChannels.vol_r[x] = a;
        }
    }
}



// Effects
// =======


// Returns: True if the virtual channels have changed.
// KEEP: X
inline func process_pitch_effects__inline(channelIndex : u8 in x) : bool in carry {
var _target_h : u8 in zpTmp;

    a = channelSoA.portamento_direction[x] as u8;
    if !zero {
        // Portamento

        if negative {
            // portamento down

            // Save target_h for later (no `cpy dp,x` instruction)
            _target_h = a = channelSoA.portamento_target_h[x];

            // Update pitch
            a = channelSoA.virtualChannels.pitch_l[x];
            y = channelSoA.virtualChannels.pitch_h[x];

            // Subtract speed from pitch
            a -= channelSoA.portamento_speed[x];
            if !carry {
                y--;
                goto Underflowed if negative;
            }

            // Test pitch against target
            cmp(y, _target_h);
            if zero {
                cmp(a, channelSoA.portamento_target_l[x]);
            }
            goto WritePitchRegisters if carry;

        Underflowed:
            // pitch < target

            // Disable portamento
            a = 0;
            channelSoA.portamento_direction[x] = a as i8;

            a = channelSoA.portamento_target_l[x];
            y = _target_h;
        }
        else {
            // portamento up

            // Save target_h for later (no `cpy dp,x` instruction)
            _target_h = a = channelSoA.portamento_target_h[x];

            a = channelSoA.virtualChannels.pitch_l[x];
            y = channelSoA.virtualChannels.pitch_h[x];

            // Add speed to pitch
            a += channelSoA.portamento_speed[x] as u8;
            if carry {
                y++;
                // PITCH is 14 bits long, no overflow test required.
            }

            // Test pitch against target
            cmp(y, _target_h);
            if zero {
                cmp(a, channelSoA.portamento_target_l[x]);
            }

            if carry {
                // Pitch >= target

                // Disable portamento
                a = 0;
                channelSoA.portamento_direction[x] = a as i8;

                a = channelSoA.portamento_target_l[x];
                y = _target_h;
            }
        }


    WritePitchRegisters:
        // ya = new pitch
        channelSoA.virtualChannels.pitch_l[x] = a;
        channelSoA.virtualChannels.pitch_h[x] = y;

        return true;
    }
    else {
        // Vibrato
        // (not active during portamento)

        y = channelSoA.vibrato_pitchOffsetPerTick[x];
        if !zero {
            // Determine the vibrato direction
            a = channelSoA.vibrato_directionComparator[x];
            cmp(a, channelSoA.vibrato_tickCounter[x]);

            if !carry {
                // Add Y to PITCH_L
                // carry clear
                channelSoA.virtualChannels.pitch_l[x] = a = y +# channelSoA.virtualChannels.pitch_l[x];

                if carry {
                    channelSoA.virtualChannels.pitch_h[x]++;
                }
            }
            else {
                // Subtract pitchOffsetPerTick from PITCH_L
                // (uses 1 less byte than reverse subtract Y, with the same CPU cycle count)
                // carry set
                a = channelSoA.virtualChannels.pitch_l[x] -# channelSoA.vibrato_pitchOffsetPerTick[x];
                channelSoA.virtualChannels.pitch_l[x] = a;

                if !carry {
                    channelSoA.virtualChannels.pitch_h[x]--;
                }
            }

            channelSoA.vibrato_tickCounter[x]--;
            if zero {
                channelSoA.vibrato_tickCounter[x] = a = channelSoA.vibrato_waveLengthInTicks[x];
            }

            return true;
        }
    }

    return false;
}


// Process Bytecode
// ================
//
// bytecode functions MUST NOT modify X.
//
// bytecode functions MUST NOT modify S-DSP registers.


// See `process_bytecode_with_loader_test()`.
func __bbs_loader_bit_set(channelIndex : u8 in x, addr : u16 in ya) {
    // Test the SWITCH_TO_LOADER_BIT a second time (just to be safe) before switching to the loader

    // (cannot use `bbc` instructions in wiz, using an `MOV1 ; bcc` instruction instead)
    carry = IO.ToDriver.switch_to_loader $ IO.ToDriver._SWITCH_TO_LOADER_BIT;
    goto process_bytecode if !carry;

    ^goto (LOADER_ADDR as func);
}


// Set the bytecode `instructionPtr` and execute the next bytecode instruction while also
// testing the if `_SWITCH_TO_LOADER_BIT` bit is set.
//
// If the `_SWITCH_TO_LOADER_BIT` bit is set, the audio driver stops execution and the loader is
// started.  This should hopefully ensure the loader will be executed if the bytecode goes off the
// rails and never sleeps.
//
// KEEP: X
//
#[fallthrough]
func process_bytecode_with_loader_test(channelIndex : u8 in x, addr : u16 in ya) {
}

// HACK: wiz does not support bbs instructions.
// Manually writing a `bbs` instruction that branches to `__bbs_loader_bit_set` if the
// _SWITCH_TO_LOADER_BIT is set. Otherwise, falls through into the `process_bytecode` instruction.
const __process_bytecode_with_loader_test : [u8 ; 3] = [
    0x3 | (IO.ToDriver._SWITCH_TO_LOADER_BIT << 5) as u8,                                   // bbs
    &IO.ToDriver.switch_to_loader as u8,                                                    // addr
    (&__bbs_loader_bit_set as i16 - &__process_bytecode_with_loader_test as i16 - 3) as u8  // rel
];



// Set the bytecode `instructionPtr` and execute the next bytecode instruction.
// KEEP: X
#[fallthrough]
func process_bytecode(channelIndex : u8 in x, addr : u16 in ya) {
    instructionPtr = ya as *const u8;

// Fallthrough
}


// Execute the next bytecode instruction
//
// KEEP: X
func process_next_bytecode(channelIndex : u8 in x) {

    y = 0;
    a = instructionPtr[y];
    instructionPtr++;

    goto bytecode._play_note if a < bytecode.N_PLAY_NOTE_INSTRUCTIONS;


    // A is a non play-note bytecode
    y = a = a & 0b11111110;

    // Push return address to the stack.
    //
    // This method uses the same number of CPU cycles (and the least amount of code space) as:
    //   * `JMP[!abs+X]` plus saving/restoring X via a zeropage register (as there is no `TXY` or `TXY` instruction
    //   * self modifying code (writing the return address of a JMP instruction)
    //

    push(a = ((&>:bytecode.InstructionTable[0] as u16 - bytecode.N_PLAY_NOTE_INSTRUCTIONS) as *u8)[y]);
    push(a = ((&<:bytecode.InstructionTable[0] as u16 - bytecode.N_PLAY_NOTE_INSTRUCTIONS) as *u8)[y]);

    if y < bytecode.FIRST_NO_ARGUMENT_INSTRUCTION_OPCODE {
        // Instruction has a parameter
        y = 0;
        a = instructionPtr[y];
        instructionPtr++;
    }

    // Y MUST be 0 if the instruction has an argument

    // Jump to the bytecode instruction routine that was just pushed onto the stack.
    return;
}



// NOTE: BYTECODE INSTRUCTIONS MUST KEEP X
//
// NOTE: If the instruction has an argument, Y will be 0
//
// Bytecode instruction must either:
//    * Return after setting `channelSoA.nextEvent_*` (to start sleeping)
//    * Jump to `process_next_bytecode` to execute the next bytecode instruction
//    * Jump to `process_bytecode` to change the bytecode instruction pointer and execute it.
//    * Jump to `process_bytecode_with_loader_test`.
//
namespace bytecode {

const InstructionTable : [u16 ; 32] = [ f as u16 for let f in INSTRUCTIONS_WITH_ARGUMENTS]
                                    ~ [ f as u16 for let f in NO_ARGUMENT_INSTRUCTIONS]
                                    ~ [ disable_channel as u16, ];

let null_instruction = disable_channel as func(u8 in x, u8 in a);



// IN: Y = 0
// KEEP: X
#[fallthrough]
func set_vibrato_depth_and_play_note(channelIndex : u8 in x, pitchOffsetPerTick: u8 in a) {
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;

    // Read first byte of `_play_note`
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

// Fallthrough
}


// Y unknown
// KEEP: x
func _play_note(channelIndex : u8 in x, noteAndKeyOffBit : u8 in a) {
    // carry = key-off after note ends bit
    a >>>= 1;

    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // calculate pitch table index
    y = a = a + channelSoA.instPitchOffset[x];

    // Set voice pitch
    channelSoA.virtualChannels.pitch_l[x] = a = commonDataHeader.pitchTable_l[y];
    channelSoA.virtualChannels.pitch_h[x] = a = commonDataHeader.pitchTable_h[y];


    // queue KON if the previous note has been KOFFed
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        a &= keyOnMask_sfx;
        test_and_set(a, keyOnShadow_sfx);

        // Disable KON the next time the note is played (slur the note)
        test_and_clear(a, keyOnMask_sfx);
    }
    else {
        a &= keyOnMask_music;
        test_and_set(a, keyOnShadow_music);

        // Disable KON the next time the note is played (slur the note)
        test_and_clear(a, keyOnMask_music);
    }


    // Get note length from the next byte in the instructionPtr
    y = 0;
    a = instructionPtr[y];
    instructionPtr++;

    channelSoA.countdownTimer[x] = a;

    // Y = 0
    // disable portamento
    channelSoA.portamento_direction[x] = y as i8;

    // Restart vibrato
    channelSoA.vibrato_tickCounter[x] = a = channelSoA.vibrato_tickCounterStart[x];
}



// IN: Y = 0
// KEEP: X
func portamento_down(channelIndex : u8 in x, speed : u8 in a) {
    channelSoA.portamento_speed[x] = a;

    return __portamento(channelIndex, -1 as u8);
}



// IN: Y = 0
// KEEP: X
#[fallthrough]
func portamento_up(channelIndex : u8 in x, speed : u8 in a) {
    channelSoA.portamento_speed[x] = a;

    // direction
    a = 1;

// Fallthrough
}


// Assumes portamento_speed already set
//
// IN: Y = 0
// KEEP: X
func __portamento(channelIndex : u8 in x, direction : u8 in a) {
    channelSoA.portamento_direction[x] = a as i8;

    // Wait length
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    channelSoA.countdownTimer[x] = a;


    // Read note target and key-off bit
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    // carry = key-off after note ends bit
    a >>>= 1;
    // Set MSB of nextEventIsKeyOff from carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // calculate pitch table index
    y = a = a + channelSoA.instPitchOffset[x];

    channelSoA.portamento_target_l[x] = a = commonDataHeader.pitchTable_l[y];
    channelSoA.portamento_target_h[x] = a = commonDataHeader.pitchTable_h[y];


    // return (do not execute the next bytecode and sleep)
    return;
}



// IN: Y = 0
// KEEP: X
func set_vibrato(channelIndex : u8 in x, pitchOffsetPerTick: u8 in a) {
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;


    // Read quarterWavelengthInTicks parameter
    // Y = 0
    a = instructionPtr[y];
    instructionPtr++;

    channelSoA.vibrato_tickCounterStart[x] = a;
    channelSoA.vibrato_tickCounter[x] = a;

    a <<<= 1;
    channelSoA.vibrato_directionComparator[x] = a;

    a <<<= 1;
    channelSoA.vibrato_waveLengthInTicks[x] = a;

    ^return process_next_bytecode(x);
}



// KEEP: X
func disable_channel(channelIndex : u8 in x) {
    // Y may not be 0

    // countdownTimer value of 0 means wait 256 ticks
    a = 0;
    channelSoA.countdownTimer[x] = a;

    // No bytecode is processed if instructionPtr_h is 0
    >:instructionPtr = a;

    // Disable portamento
    channelSoA.portamento_direction[x] = a as i8;

    // Disable vibrato
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;


    // Send key-off event
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        test_and_set(a, keyOffShadow_sfx);

        // Disable echo
        test_and_clear(a, eonShadow_sfx);

        // Disable sfx S-DSP writes.
        test_and_clear(a, activeSoundEffects);
    }
    else {
        test_and_set(a, keyOffShadow_music);
    }

    // return (do not execute the next bytecode and sleep)
    return;
}


// KEEP: X
func end(channelIndex : u8 in x) {
    a = channelSoA.instructionPtrAfterEnd_h[x];
    goto disable_channel if zero;

    y = a;
    a = channelSoA.instructionPtrAfterEnd_l[x];

    ^return process_bytecode_with_loader_test(x, ya);
}


// IN: Y = 0
// KEEP: X
func call_subroutine(channelIndex : u8 in x, subroutineId : u8 in a) {
var _subroutineId : u8 in zpTmp;

    // Disable vibrato
    // Y = 0
    channelSoA.vibrato_pitchOffsetPerTick[x] = y;

    y = a;

    // Save return address
    channelSoA.returnInstPtr_l[x] = a = <:instructionPtr;
    channelSoA.returnInstPtr_h[x] = a = >:instructionPtr;

    // Add songPtr to subroutineTable[y] to get the subroutine address
    <:instructionPtr = a = (subroutineTable_l as *u8)[y] + <:songPtr;
    >:instructionPtr = a = (subroutineTable_h as *u8)[y] +# >:songPtr;

    ^return process_next_bytecode(x);
}



// KEEP: X
func return_from_subroutine(channelIndex : u8 in x) {
    // Disable channel if not in a subroutine.
    a = channelSoA.returnInstPtr_h[x];
    goto disable_channel if zero;

    y = a;

    // Reset subroutine return ptr and vibrato
    a = 0;
    channelSoA.returnInstPtr_h[x] = a;
    channelSoA.vibrato_pitchOffsetPerTick[x] = a;

    a = channelSoA.returnInstPtr_l[x];

    ^return process_bytecode_with_loader_test(x, ya);
}


// KEEP: X
inline func __start_loop(channelIndex : u8 in x, loopCount : u8 in a, let LOOP_ID : u8) {
    let _loopState_counter     = &channelSoA.loopState_counter[LOOP_ID] as *u8;
    let _loopState_loopPoint_l = &channelSoA.loopState_loopPoint_l[LOOP_ID] as *u8;
    let _loopState_loopPoint_h = &channelSoA.loopState_loopPoint_h[LOOP_ID] as *u8;

    _loopState_counter[x] = a;

    ya = instructionPtr as u16;

    _loopState_loopPoint_l[x] = a;
    _loopState_loopPoint_h[x] = a = y;

    ^return process_next_bytecode(x);
}


// KEEP: X
inline func __skip_last_loop(channelIndex : u8 in x, bytesToSkip : u8 in a, let LOOP_ID : u8) {
    let _loopState_counter     = &channelSoA.loopState_counter[LOOP_ID] as *u8;
    let _loopState_loopPoint_l = &channelSoA.loopState_loopPoint_l[LOOP_ID] as *u8;
    let _loopState_loopPoint_h = &channelSoA.loopState_loopPoint_h[LOOP_ID] as *u8;

    // Add `bytesToSkip` to `instructionPtr` if counter == 1
    y = _loopState_counter[x];
    y--;
    if zero {
        // Y = 0
        ya += instructionPtr as u16;
        ^return process_bytecode(x, ya);
    }

    ^return process_next_bytecode(x);
}


// KEEP: X
inline func __end_loop(channelIndex : u8 in x, let LOOP_ID : u8) {
    let _loopState_counter     = &channelSoA.loopState_counter[LOOP_ID] as *u8;
    let _loopState_loopPoint_l = &channelSoA.loopState_loopPoint_l[LOOP_ID] as *u8;
    let _loopState_loopPoint_h = &channelSoA.loopState_loopPoint_h[LOOP_ID] as *u8;

    _loopState_counter[x]--;
    if !zero {
        y = a = _loopState_loopPoint_h[x];
        a = _loopState_loopPoint_l[x];

        ^return process_bytecode_with_loader_test(x, ya);
    }
    ^return process_next_bytecode(x);
}


// KEEP: X
func start_loop_0(channelIndex : u8 in x, loopCount : u8 in a) {
    return __start_loop(x, a, 0);
}

// KEEP: X
func start_loop_1(channelIndex : u8 in x, loopCount : u8 in a) {
    return __start_loop(x, a, 1);
}

// KEEP: X
func start_loop_2(channelIndex : u8 in x, loopCount : u8 in a) {
    return __start_loop(x, a, 2);
}

// KEEP: X
func skip_last_loop_0(channelIndex : u8 in x, loopCount : u8 in a) {
    return __skip_last_loop(x, a, 0);
}

// KEEP: X
func skip_last_loop_1(channelIndex : u8 in x, loopCount : u8 in a) {
    return __skip_last_loop(x, a, 1);
}

// KEEP: X
func skip_last_loop_2(channelIndex : u8 in x, loopCount : u8 in a) {
    return __skip_last_loop(x, a, 2);
}

// KEEP: X
func end_loop_0(channelIndex : u8 in x) {
    return __end_loop(x, 0);
}

// KEEP: X
func end_loop_1(channelIndex : u8 in x) {
    return __end_loop(x, 1);
}

// KEEP: X
func end_loop_2(channelIndex : u8 in x) {
    return __end_loop(x, 2);
}



// KEEP: X
func enable_echo(channelIndex : u8 in x) {
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        test_and_set(a, eonShadow_sfx);
        ^return process_next_bytecode(x);
    }
    else {
        test_and_set(a, eonShadow_music);
        ^return process_next_bytecode(x);
    }
}



// KEEP: X
func disable_echo(channelIndex : u8 in x) {
    a = ChannelVoiceBit[x];
    if x >= FIRST_SFX_CHANNEL {
        test_and_clear(a, eonShadow_sfx);
        ^return process_next_bytecode(x);
    }
    else {
        test_and_clear(a, eonShadow_music);
        ^return process_next_bytecode(x);
    }

    ^return process_next_bytecode(x);
}



// KEEP: X
func set_instrument(channelIndex : u8 in x, instrumentId : u8 in a) {
    y = a;

    channelSoA.instPitchOffset[x] = a = commonData.instruments_pitchOffset[y];

    channelSoA.virtualChannels.scrn[x] = a = commonData.instruments_scrn[y];
    channelSoA.virtualChannels.adsr1[x] = a = commonData.instruments_adsr1[y];
    channelSoA.virtualChannels.adsr2OrGain[x] = a = commonData.instruments_adsr2OrGain[y];

    ^return process_next_bytecode(x);
}



// KEEP: X
func set_instrument_and_adsr_or_gain(channelIndex : u8 in x, instrumentId : u8 in a) {
    y = a;

    channelSoA.instPitchOffset[x] = a = commonData.instruments_pitchOffset[y];

    channelSoA.virtualChannels.scrn[x] = a = commonData.instruments_scrn[y];

    // Read ADSR/GAIN from `instructionPtr`.
    y = 0;
    channelSoA.virtualChannels.adsr1[x] = a = instructionPtr[y];
    instructionPtr++;

    channelSoA.virtualChannels.adsr2OrGain[x] = a = instructionPtr[y];
    instructionPtr++;

    ^return process_next_bytecode(x);
}



// IN: Y = 0
// KEEP: X
func set_adsr(channelIndex: u8 in x, adsr1 : u8 in a) {
    channelSoA.virtualChannels.adsr1[x] = a;

    // Y = 0
    channelSoA.virtualChannels.adsr2OrGain[x] = a = instructionPtr[y];
    instructionPtr++;

    ^return process_next_bytecode(x);
}



// IN: Y = 0
// KEEP: X
func set_gain(channelIndex: u8 in x, gain : u8 in a) {
    // Y = 0
    channelSoA.virtualChannels.adsr1[x] = y;

    channelSoA.virtualChannels.adsr2OrGain[x] = a;

    ^return process_next_bytecode(x);
}


// KEEP: X
#[fallthrough]
func adjust_pan(channelIndex : u8 in x, detla : i8 in a) {
    carry = false;

    y = a;
    if negative {
        // carry clear, A is negative
        a +#= channelSoA.pan[x];
        if !carry {
            a = 0;
        }
    }
    else {
        // carry clear, A is positive
        a += channelSoA.pan[x];
        if carry || a >= MAX_PAN + 1 {
            a = MAX_PAN;
        }
    }

// Fallthrough
}



// KEEP: X
func set_pan(channelIndex : u8 in x, pan : u8 in a) {
    channelSoA.pan[x] = a;

    clear_vol_shadow_valid_flag(x);

    ^return process_next_bytecode(x);
}



// REQUIRES: Y = 0
// KEEP: X
func set_pan_and_volume(channelIndex : u8 in x, pan : u8 in a) {
    // Y is 0

    channelSoA.pan[x] = a;

    a = instructionPtr[y];
    instructionPtr++;

    return set_volume(x, a);
}



// KEEP:X
#[fallthrough]
func adjust_volume(channelIndex : u8 in x, delta: i8 in a) {
    carry = false;

    y = a;
    if negative {
        // carry clear, A is negative
        a +#= channelSoA.volume[x];
        if !carry {
            a = 0;
        }
    }
    else {
        // carry clear, A is positive
        a +#= channelSoA.volume[x];
        if carry {
            a = 0xff;
        }
    }

// Fallthrough
}


// KEEP: X
#[fallthrough]
func set_volume(channelIndex : u8 in x, volume : u8 in a) {
    channelSoA.volume[x] = a;

    clear_vol_shadow_valid_flag(x);

    ^return process_next_bytecode(x);
}


// KEEP: x
#[fallthrough]
func rest_keyoff(channelIndex : u8 in x, length: u8 in a) {
    channelSoA.nextEventIsKeyOff[x] = y = 1;
// Fallthrough
}


// KEEP: x
func rest(channelIndex : u8 in x, length: u8 in a) {
    channelSoA.countdownTimer[x] = a;

    // return (do not execute the next bytecode and sleep)
    return;
}

// Sets the timer for the music channels
//
// KEEP: x
func set_song_tick_clock(channelIndex : u8 in x, timer_clock: u8 in a) {
    if a < MIN_TICK_CLOCK {
        a = MIN_TICK_CLOCK;
    }

    smp.timer_0 = a;

    ^return process_next_bytecode(x);
}

}

}



// Data Tables
// ===========

// Using the `code` bank so the data is included in `audio-driver.bin`
in code {
    // The S-DSP voice used by each channel
    let __VOICE_CHANNELS = [0, 1, 2, 3, 4, 5, 6, 7, 6, 7];

    // The bit used for global DSP registers (KON, KOFF, NON, EON, etc)
    const ChannelVoiceBit : [u8; N_CHANNELS] = [1 << i for let i in __VOICE_CHANNELS];

    // The address of the last writeable voice DSP register for each channel
    const LastVoiceRegister : [u8; N_CHANNELS] = [i * 0x10 | 0x07 for let i in __VOICE_CHANNELS];

    // Used by `stop_sound_effects`.
    const ChannelDisabledBytecode : [ u8; 1 ] = [ bytecode.DISABLE_CHANNEL_BYTECODE ];
}

import "bytecode";

